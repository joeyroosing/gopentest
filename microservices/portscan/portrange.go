package main

import (
	"errors"
	"fmt"
	"strings"
)

var (
	errPortRange          = errors.New("Port must be between 1 and 65535")
	errPortStartRange     = errors.New("Start port must be between 1 and 65533")
	errPortEndRange       = errors.New("End port cannot be bigger than 65535")
	errPortEndBeforeStart = errors.New("End port can not be greater then start port")
	errPortStartEndRange  = func(p int32) error {
		return fmt.Errorf("End port cannot be smaller than %d", p)
	}
	errPortInvalidRange = func(p string) error {
		return fmt.Errorf("Invalid port range: %s", p)
	}
)

//SplitPorts splits individual ports and port ranges based
//on the given delimiters.
//singlePortDelimiter functions for individual ports
//rangeDelimiter functions for port ranges
func SplitPorts(ports, singlePortDelimiter, rangeDelimiter string) ([]int32, error) {
	var portSlice []int32

	if !strings.Contains(ports, singlePortDelimiter) && !strings.Contains(ports, rangeDelimiter) {
		p, err := ConvertPort(ports)
		if err != nil {
			return nil, err
		}
		portSlice = append(portSlice, int32(p))
		return portSlice, nil
	}

	const isSinglePort = 1 // e.g. "22"
	const isPortRange = 2  // e.g. "22-42" depending on the delimiter

	for _, port := range strings.Split(ports, singlePortDelimiter) {
		p := strings.Split(port, rangeDelimiter)

		switch len(p) {
		// single port if result of p = 1, e.g. it was not Split
		case isSinglePort:
			n, err := ConvertPort(p[0])
			if err != nil {
				return nil, err
			}
			portSlice = append(portSlice, int32(n))
		// true if len(p) > 2
		case isPortRange:
			start, end, err := parsePortRange(p[0], p[1])
			if err != nil {
				return nil, err
			}
			// add port in range to slice
			for i := start; i < end+1; i++ {
				portSlice = append(portSlice, int32(i))
			}
		}
	}
	return portSlice, nil
}

func parsePortRange(start, end string) (int32, int32, error) {
	s, err := ConvertPort(start)
	if err != nil {
		return 0, 0, err
	}

	e, err := ConvertPort(end)
	if err != nil {
		return 0, 0, err
	}

	if e < s+2 {
		return 0, 0, errPortEndBeforeStart
	}
	return s, e, nil
}
