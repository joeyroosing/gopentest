package main

import (
	"fmt"
	"net"
	"sync"
	"time"

	"github.com/joeyroosing/gopentest/pb/portscan"
	"golang.org/x/net/context"
)

var (
	errInvalidIP = func(s string) error {
		return fmt.Errorf("Invalid ip: %s", s)
	}
)

type service struct{}

func (s *service) hostPort(host string, port int32) string {
	return fmt.Sprintf("%s:%d", host, port)
}

func newService() *service {
	s := &service{}
	return s
}

// ScanPorts scans all give ports for a specific port range and ip
func (s *service) ScanPorts(context context.Context, req *portscan.ScanPortsRequest) (*portscan.ScanPortsResult, error) {
	if !IsIP(req.Ip) {
		return nil, errInvalidIP(req.Ip)
	}

	splitPorts, err := SplitPorts(req.PortRange, ",", "-")
	if err != nil {
		return nil, err
	}

	ip := req.Ip
	var results []*portscan.ScanResult

	ch := make(chan *portscan.ScanResult)

	// launch the producer goroutine
	go func() {
		var wg sync.WaitGroup
		wg.Add(len(splitPorts))
		for _, port := range splitPorts {
			go func(port int32) {
				defer wg.Done()
				ch <- connect(ip, port, req.Timeout)
			}(port)
		}
		wg.Wait()
		close(ch)
	}()

	for elem := range ch {
		results = append(results, elem)
	}

	return &portscan.ScanPortsResult{
		ScanResults: results,
	}, nil
}

func connect(ip string, port, timeout int32) *portscan.ScanResult {
	res := &portscan.ScanResult{
		Port:   port,
		IsOpen: false,
	}
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:%d", ip, port), time.Duration(timeout)*time.Millisecond)
	if err == nil {
		conn.Close()
		res.IsOpen = true
	}
	return res
}
